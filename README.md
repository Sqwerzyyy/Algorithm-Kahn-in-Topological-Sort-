Порівняльний аналіз алгоритму Кана для топологічного сортування

Опис проекту

Цей проект присвячений реалізації та дослідженню ефективності алгоритму Кана (Kahn's Algorithm) для топологічного сортування орієнтованих ациклічних графів (DAG).

Головна мета роботи — порівняти продуктивність алгоритму при використанні двох різних структур даних для представлення графу:

Список суміжності (Adjacency List)
Матриця суміжності (Adjacency Matrix)
Функціонал

Генерація випадкових DAG: Власний генератор графів, який гарантує відсутність циклів
Дві реалізації алгоритму:

Оптимізована версія для списку суміжності (O(V + E))
Версія для матриці суміжності (O(V²))
Автоматизований бенчмарк: Проведення серії експериментів із різною кількістю вершин та щільністю ребер
Зручний вивід: Результати відображаються у вигляді форматованої таблиці в консолі
Структура проекту

Проект написаний на чистому Python без використання зовнішніх бібліотек для алгоритмів (NetworkX тощо), що забезпечує чистоту експерименту.

Основний функціонал:

generate_random_dag: Функція створення випадкового графу без циклів (ребра йдуть лише від i до j, де i < j)
kahn_sort_adjacency_list: Реалізація алгоритму через deque та список суміжності
kahn_sort_adjacency_matrix: Реалізація алгоритму через повний перебір рядків матриці
run_experiments: Модуль тестування, що заміряє "чистий" час роботи алгоритму (без урахування генерації даних)
Методологія експерименту

Для дослідження були обрані наступні параметри:

Розмір графу (V): 100, 300, 500 вершин
Щільність графу (Density):

0.1 (розріджений граф, 10% можливих ребер)
0.5 (середній граф)
0.8 (щільний граф, 80% можливих ребер)
Кількість повторів: Кожен тест проганяється 5 разів для отримання середнього значення часу
Висновки та аналіз результатів

1. Список суміжності (Adjacency List)

Теоретична складність: O(V + E)
Результати: Час виконання зростає лінійно залежно від кількості ребер. Це найбільш ефективний спосіб зберігання для розріджених графів
Спостереження: При низькій щільності (0.1) алгоритм працює миттєво навіть на великих графах
2. Матриця суміжності (Adjacency Matrix)

Теоретична складність: O(V²)
Результати: Час виконання залежить квадратично від кількості вершин і майже не залежить від щільності (кількості ребер)
Спостереження: Алгоритм змушений перевіряти весь рядок матриці (V елементів) для кожної вершини, навіть якщо у неї немає сусідів. Це робить його значно повільнішим за список суміжності на великих графах
Підсумок

Експериментально підтверджено, що список суміжності є значно ефективнішою структурою даних для реалізації алгоритму Кана, перевищуючи матрицю суміжності у швидкодії в 10-15 разів на тестових даних.
Знизу опис деяких кусків коду, з коментарями по тому що виконують певні строки коду 

Цей код реалізує класичний алгоритм Кана для розріджених графів. Ключовим елементом є використання deque для збереження вершин з нульовим вхідним степенем. Цикл for v in graph[u] гарантує, що ми виконуємо операції лише для реально існуючих ребер, що забезпечує лінійну складність O(V+E).


    def kahn_sort_adjacency_list(n_vertices, graph, in_degree):
    """
    реалізація для списку суміжності
    часова складність: O(V + E)
    """
    # 1 ініціалізуємо чергу всіма вершинами, у яких немає вхідних ребер (in_degree == 0)
    queue = deque([v for v in range(n_vertices) if in_degree[v] == 0])
    topo_order = []
     while queue:
        # 2 витягуємо вершину з черги та додаємо її до результату
        u = queue.popleft()
        topo_order.append(u)

        # 3 проходимо ТІЛЬКИ!!! по існуючих сусідах
        # це ключовий момент ефективності: якщо сусідів немає, цикл не виконується
        for v in graph[u]:
            in_degree[v] -= 1
            # якщо після видалення ребра у сусіда не залишилось вхідних зв'язків
            if in_degree[v] == 0:
                queue.append(v)
    return topo_order
У цій реалізації для пошуку сусідів поточної вершини U програма змушена ітеруватись по всіх вершинах графу від 0 до V−1. Це необхідно, оскільки структура матриці не дозволяє миттєво отримати список сусідів без повного перебору рядка. Це призводить до квадратичної складності O(V 
2
 ), що робить алгоритм неефективним на великих графах.

    def kahn_sort_adjacency_matrix(n_vertices, graph, in_degree):
    """
    Реалізація для Матриці Суміжності.
    часова складність: O(V^2)
    """
    queue = deque([v for v in range(n_vertices) if in_degree[v] == 0])
    topo_order = []
    while queue:
        u = queue.popleft()
        topo_order.append(u)

        # 3 усимо перевірити всеь рядок матриці (всі можливі вершини)
        # навіть якщо ребра не існує (там 0), ми все одно витрачаємо час на перевірку
        for v in range(n_vertices):
            if graph[u][v] == 1:
                in_degree[v] -= 1
                if in_degree[v] == 0:
                    queue.append(v)
                    
    return topo_order

Функція гарантує створення ациклічного графу (DAG) шляхом обмеження напрямку ребер: ребро може існувати лише від вершини i до вершини j, де i<j. Такий підхід автоматично виключає можливість зворотних шляхів, а отже, і циклів. Параметр density визначає ймовірність створення кожного конкретного ребра.

    def generate_random_dag(n, density, rep_type):
    """
    Генерує випадковий орієнтований ациклічний граф (DAG).
    """
    # словник для підрахунку вхідних степенів (потрібен для алгоритму Кана)
    in_degree = {i: 0 for i in range(n)}
    # ініціалізація порожнього графу залежно від типу
    if rep_type == 'list':
        graph = {i: [] for i in range(n)}
        
        # 1. подвійний цикл проходить тільки по верхньому трикутнику матриці
        # умова j > i гарантує, що ребра йдуть тільки від меншого індексу до більшого
        # це математично унеможливлює створення циклів
        for i in range(n):
            for j in range(i + 1, n):
                # 2. ймовірнісне додавання ребра
                if random.random() < density:
                    graph[i].append(j)
                    in_degree[j] += 1
                    
    # ... (аналогічно для матриці)
    return graph, in_degree
Для забезпечення чистоти експерименту процеси генерації даних та вимірювання швидкодії розділені. Час заміряється за допомогою time.perf_counter(), який є стандартом для бенчмаркінгу в Python. Важливо, що в замір входить лише робота функції сортування, а допоміжні операції (генерація графу, виділення пам'яті) залишаються за межами таймера.
#фрагмент з функції run_experiments
#1 етап підготовки даних
graph, in_degree, edges = generate_random_dag(n, d, 'list')
#робимо копію масиву вхідних степенів, бо алгоритм його модифікує
#це дозволяє не включати час копіювання у замір швидкодії
in_degree_copy = in_degree.copy()
#2 початок заміру
#perf_counter забезпечує найвищу доступну точність таймера
start = time.perf_counter()
#3 виконання алгоритму
kahn_sort_adjacency_list(n, graph, in_degree_copy)
#4 кінець заміру
end = time.perf_counter()
#обчислення чистого часу виконання
execution_time = end - start 
не знаю чому воно зараз так показує, можете зайти в код рід мі і там гарніше виглядає останні строки тексту з поясненням про чистоту експерименту 
